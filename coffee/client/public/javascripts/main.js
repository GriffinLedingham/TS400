// Generated by CoffeeScript 1.6.3
var KEYCODE_A, KEYCODE_D, KEYCODE_DOWN, KEYCODE_ENTER, KEYCODE_LEFT, KEYCODE_RIGHT, KEYCODE_S, KEYCODE_SPACE, KEYCODE_UP, KEYCODE_W, canvas, dnHeld, doneLoading, fwdHeld, getGPSLocation, gps, gpsDataSuccess, handleClick, handleComplete, handleKeyDown, handleKeyUp, init, level, lfHeld, loader, mapData, player, playerSprite, preload, restart, rtHeld, stage, tick, tileset;

KEYCODE_ENTER = 13;

KEYCODE_SPACE = 32;

KEYCODE_UP = 38;

KEYCODE_LEFT = 37;

KEYCODE_RIGHT = 39;

KEYCODE_DOWN = 40;

KEYCODE_W = 87;

KEYCODE_A = 65;

KEYCODE_S = 83;

KEYCODE_D = 68;

lfHeld = void 0;

rtHeld = void 0;

fwdHeld = void 0;

dnHeld = void 0;

canvas = void 0;

stage = void 0;

tileset = void 0;

mapData = void 0;

loader = void 0;

player = void 0;

playerSprite = void 0;

level = void 0;

gps = void 0;

preload = void 0;

init = function() {
  var manifest, messageField;
  getGPSLocation();
  canvas = document.getElementById("gameCanvas");
  stage = new createjs.Stage(canvas);
  messageField = new createjs.Text("Loading", "bold 24px Arial", "#FFFFFF");
  messageField.maxWidth = 1000;
  messageField.textAlign = "center";
  messageField.x = canvas.width / 2;
  messageField.y = canvas.height / 2;
  manifest = [
    {
      src: "images/runningRpg.png",
      id: "player"
    }
  ];
  loader = new createjs.LoadQueue(false);
  loader.addEventListener("complete", handleComplete);
  loader.loadManifest(manifest);
  stage.addChild(messageField);
  return stage.update();
};

handleComplete = function(event) {
  var data;
  data = new createjs.SpriteSheet({
    images: [loader.getResult("player")],
    frames: {
      regX: 100,
      height: 292,
      count: 12,
      regY: 165 / 2,
      width: 165
    },
    animations: {
      up: [0, 2, "up"],
      right: [3, 5, "right"],
      down: [6, 8, "down"],
      left: [9, 11, "left"],
      left_idle: [9, 9],
      right_idle: [3, 3],
      up_idle: [0, 0],
      down_idle: [6, 6]
    }
  });
  playerSprite = new createjs.Sprite(data, "right_idle");
  playerSprite.framerate = 10;
  return doneLoading();
};

doneLoading = function(event) {
  return restart();
};

handleClick = function() {
  canvas.onclick = null;
  return stage.removeChild(messageField);
};

restart = function() {
  stage.removeAllChildren();
  player = new Player(playerSprite, stage);
  player.x = canvas.width / 2;
  player.y = canvas.height / 2;
  player.width = 165;
  player.height = 292;
  lfHeld = rtHeld = fwdHeld = dnHeld = false;
  stage.clear();
  level = new Level(stage);
  stage.addChild(player);
  if (!createjs.Ticker.hasEventListener("tick")) {
    return createjs.Ticker.addEventListener("tick", tick);
  }
};

tick = function(event) {
  var keys;
  keys = [];
  if (fwdHeld) {
    keys.push("up");
  }
  if (dnHeld) {
    keys.push("down");
  }
  if (lfHeld) {
    keys.push("left");
  }
  if (rtHeld) {
    keys.push("right");
  }
  player.accelerate(keys);
  player.tick(event, level);
  if (player.x > canvas.width * .5) {
    stage.x = -player.x + canvas.width * .5;
  }
  if (player.y > canvas.height * .5) {
    stage.y = -player.y + canvas.height * .5;
  }
  return stage.update(event);
};

handleKeyDown = function(e) {
  var shootHeld;
  if (!e) {
    e = window.event;
  }
  switch (e.keyCode) {
    case KEYCODE_SPACE:
      shootHeld = true;
      return false;
    case KEYCODE_A:
    case KEYCODE_LEFT:
      lfHeld = true;
      return false;
    case KEYCODE_D:
    case KEYCODE_RIGHT:
      rtHeld = true;
      return false;
    case KEYCODE_W:
    case KEYCODE_UP:
      fwdHeld = true;
      return false;
    case KEYCODE_S:
    case KEYCODE_DOWN:
      dnHeld = true;
      return false;
    case KEYCODE_ENTER:
      if (canvas.onclick === handleClick) {
        handleClick();
      }
      return false;
  }
};

handleKeyUp = function(e) {
  var shootHeld;
  if (!e) {
    e = window.event;
  }
  switch (e.keyCode) {
    case KEYCODE_SPACE:
      return shootHeld = false;
    case KEYCODE_A:
    case KEYCODE_LEFT:
      return lfHeld = false;
    case KEYCODE_D:
    case KEYCODE_RIGHT:
      return rtHeld = false;
    case KEYCODE_W:
    case KEYCODE_UP:
      return fwdHeld = false;
    case KEYCODE_S:
    case KEYCODE_DOWN:
      return dnHeld = false;
  }
};

gpsDataSuccess = function(data) {
  gps = data.coords;
  return console.log(gps.latitude, gps.longitude);
};

getGPSLocation = function() {
  if (navigator.geolocation) {
    return navigator.geolocation.getCurrentPosition(gpsDataSuccess);
  }
};

document.onkeydown = handleKeyDown;

document.onkeyup = handleKeyUp;

(function(window) {
  var Level, httpGet, httpGetData, initLayer, initLayers, p;
  Level = function(stage) {
    this.initialize();
    return this.stage = stage;
  };
  p = Level.prototype = new createjs.Container();
  p.stage;
  tileset = void 0;
  mapData = void 0;
  p.Container_initialize = p.initialize;
  initLayers = function() {
    var h, idx, imageData, layerData, tilesetSheet, w, _results;
    w = mapData.tilesets[0].tilewidth;
    h = mapData.tilesets[0].tileheight;
    imageData = {
      images: [tileset],
      frames: {
        width: w,
        height: h
      }
    };
    tilesetSheet = new createjs.SpriteSheet(imageData);
    idx = 0;
    _results = [];
    while (idx < mapData.layers.length) {
      layerData = mapData.layers[idx];
      if (layerData.type === "tilelayer") {
        initLayer(layerData, tilesetSheet, mapData.tilewidth, mapData.tileheight);
      }
      _results.push(idx++);
    }
    return _results;
  };
  initLayer = function(layerData, tilesetSheet, tilewidth, tileheight) {
    var cellSprite, idx, x, y, _results;
    y = 0;
    console.log(layerData);
    _results = [];
    while (y < layerData.height) {
      x = 0;
      while (x < layerData.width) {
        cellSprite = new createjs.Sprite(tilesetSheet);
        idx = x + y * layerData.width;
        if (layerData.data[idx] !== 0) {
          cellSprite.gotoAndStop(layerData.data[idx] - 1);
          cellSprite.x = x * tilewidth;
          cellSprite.y = y * tileheight;
          cellSprite.num = layerData.name;
          cellSprite.hit = layerData.properties.hit;
          cellSprite.type = 'tile';
          this.stage.addChild(cellSprite);
        }
        x++;
      }
      _results.push(y++);
    }
    return _results;
  };
  httpGet = function(theUrl) {
    var xmlHttp;
    xmlHttp = null;
    xmlHttp = new XMLHttpRequest();
    xmlHttp.open("GET", theUrl, false);
    xmlHttp.send(null);
    return xmlHttp.responseText;
  };
  httpGetData = function(theUrl) {
    var responseText;
    responseText = httpGet(theUrl);
    return JSON.parse(responseText);
  };
  p.initialize = function(sprite) {
    this.Container_initialize();
    return $.ajax({
      url: "images/Level1.json",
      async: false,
      dataType: "json",
      success: function(response) {
        mapData = response;
        tileset = new Image();
        tileset.src = mapData.tilesets[0].image;
        return tileset.onLoad = initLayers();
      }
    });
  };
  return window.Level = Level;
})(window);

(function(window) {
  var MAX_VELOCITY, Player, p;
  Player = function(sprite, stage) {
    return this.initialize(sprite, stage);
  };
  p = Player.prototype = new createjs.Container();
  p.vX;
  p.vY;
  p.bounds;
  p.hit;
  p.lastKey;
  MAX_VELOCITY = 20;
  stage;
  p.Container_initialize = p.initialize;
  p.initialize = function(sprite, stage) {
    this.Container_initialize();
    this.playerBody = sprite;
    stage = stage;
    this.addChild(this.playerBody);
    this.vX = 0;
    return this.vY = 0;
  };
  p.tick = function(event, level) {
    var bottom_side, hit, left_side, right_side, top_side, view;
    view = this;
    hit = false;
    right_side = view.x + view.width / 2;
    left_side = view.x - view.width / 2;
    top_side = view.y + view.height / 2;
    bottom_side = view.y - view.height / 2;
    stage.children.forEach(function(child) {
      if (child.type === "tile") {
        if (child.hit === "true") {
          if (right_side > child.x && right_side < child.x + 96 && view.y > child.y && view.y < child.y + 96) {
            hit = true;
            view.x -= 5;
          }
          if (left_side < child.x + 96 && left_side > child.x && view.y > child.y && view.y < child.y + 96) {
            hit = true;
            view.x += 5;
          }
          if (view.x > child.x && view.x < child.x + 96 && top_side < child.y + 96 && top_side > child.y) {
            hit = true;
            view.y += 5;
          }
          if (view.x > child.x && view.x < child.x + 96 && bottom_side < child.y && bottom_side < child.y + 96) {
            hit = true;
            return view.y -= 5;
          }
        }
      }
    });
    if (hit !== true) {
      this.x += this.vX;
      return this.y += this.vY;
    }
  };
  p.accelerate = function(keys) {
    var latestKey, view;
    view = this;
    view.vX = 0;
    view.vY = 0;
    latestKey = false;
    keys.forEach(function(key) {
      if (key === "left") {
        view.vX += -MAX_VELOCITY;
      }
      if (key === "right") {
        view.vX += MAX_VELOCITY;
      }
      if (key === "up") {
        view.vY += -MAX_VELOCITY;
      }
      if (key === "down") {
        view.vY += MAX_VELOCITY;
      }
      return latestKey = key;
    });
    if (latestKey !== false) {
      if (this.playerBody.currentAnimation !== "run") {
        this.playerBody.gotoAndPlay("run");
      }
    } else {
      this.playerBody.gotoAndPlay("idle");
    }
    switch (latestKey) {
      case "left":
        if (this.playerBody.currentAnimation !== "left") {
          this.playerBody.gotoAndPlay("left");
          this.lastKey = "left";
        }
        break;
      case "right":
        if (this.playerBody.currentAnimation !== "right") {
          this.playerBody.gotoAndPlay("right");
          this.lastKey = "right";
        }
        break;
      case "up":
        if (this.playerBody.currentAnimation !== "up") {
          this.playerBody.gotoAndPlay("up");
          this.lastKey = "up";
        }
        break;
      case "down":
        if (this.playerBody.currentAnimation !== "down") {
          this.playerBody.gotoAndPlay("down");
          this.lastKey = "down";
        }
        break;
      default:
        switch (this.lastKey) {
          case "left":
            this.playerBody.gotoAndPlay("left_idle");
            break;
          case "up":
            this.playerBody.gotoAndPlay("up_idle");
            break;
          case "down":
            this.playerBody.gotoAndPlay("down_idle");
            break;
          case "right":
            this.playerBody.gotoAndPlay("right_idle");
            break;
        }
    }
    if (this.vX > MAX_VELOCITY) {
      this.vX = MAX_VELOCITY;
    }
    if (this.vX < -MAX_VELOCITY) {
      this.vX = -MAX_VELOCITY;
    }
    if (this.vY > MAX_VELOCITY) {
      this.vY = MAX_VELOCITY;
    }
    if (this.vY < -MAX_VELOCITY) {
      return this.vY = -MAX_VELOCITY;
    }
  };
  return window.Player = Player;
})(window);
